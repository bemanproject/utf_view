---
title: "Endian Views"
document: P9999R0
date: 2026-02-22
audience:
  - SG-9 Ranges
  - LEWG
author:
  - name: Eddie Nolan
    email: <eddiejnolan@gmail.com>
toc: true
monofont: "DejaVu Sans Mono"

---

# Motivation

The main reason for adding these views is to assist users of the UTF transcoding range adaptors (see [@P2728R10]). That paper introduces the adaptors `to_utf8`, `to_utf16`, and `to_utf32`, which take as input ranges of `char8_t`, `char16_t`, and `char32_t`. The input and output of these views use native endianness. But users often need to convert to and from UTF encodings with specific endianness: UTF-16LE, UTF-16BE, UTF-32LE, and UTF-32BE.

Rather than introduce a combinatorial explosion of UTF adaptors with various endianness of input and output, we should follow the single responsibility principle and add standard endianness views so users can handle endianness separately.

In addition to UTF transcoding, this facility will help users handle the endianness of other streams of data, such as network protocols like [TODO Claude help me] and file formats like [TODO Claude help me].

# Dependencies

This paper depends on [@P3117R1] "Extending Conditionally Borrowed".

# Wording

Add the following subclause to [range.adaptors]{.sref}:

## 24.7.? Endianness adaptors [range.codeunitadaptor] {-}

```cpp
template<class T>
struct @*byteswap-functor*@ { // @*exposition only*@/
  constexpr T operator()(auto x) const noexcept { return x; }
};
```

The name `byteswap` denotes a range adaptor object ([range.adaptor.object]). Let `E` be an expression and let `T` be `remove_cvref_t<decltype((E))>`. If `ranges::range_reference_t<T>` does not model `integral`, `byteswap(E)` is ill-formed. The expression `byteswap(E)` is expression-equivalent to:

- If `T` is a specialization of `empty_view` ([range.empty.view]), then
  `empty_view<T>{}`.
- Otherwise, `ranges::transform_view(std::views::all(E), @*byteswap-functor*@{})`.

```cpp
template<class T>
struct @*little-endian-to-native-functor*@ { // @*exposition only*@/
  constexpr T operator()(auto x) const noexcept {
    if constexpr (endian::native == endian::big) {
      return std::byteswap(x);
    } else {
      return x; 
    }
  }
};
```

```cpp
template<class T>
struct @*big-endian-to-native-functor*@ { // @*exposition only*@/
  constexpr T operator()(auto x) const noexcept {
    if constexpr (endian::native == endian::little) {
      return std::byteswap(x);
    } else {
      return x; 
    }
  }
};
```

If `std::endian::native != std::endian::big` and `std::endian::native != std::endian::little`, the following two range adaptor objects are not provided. Otherwise:

The name `little_endian_to_native` denotes a range adaptor object ([range.adaptor.object]). Let `E` be an expression and let `T` be `remove_cvref_t<decltype((E))>`. If `ranges::range_reference_t<T>` does not model `integral`, `little_endian_to_native(E)` is ill-formed. The expression `little_endian_to_native(E)` is expression-equivalent to:

- If `T` is a specialization of `empty_view` ([range.empty.view]), then
  `empty_view<T>{}`.
- Otherwise, `ranges::transform_view(std::views::all(E), @*little-endian-to-native-functor*@{})`.

The name `big_endian_to_native` denotes a range adaptor object ([range.adaptor.object]). Let `E` be an expression and let `T` be `remove_cvref_t<decltype((E))>`. If `ranges::range_reference_t<T>` does not model `integral`, `big_endian_to_native(E)` is ill-formed. The expression `big_endian_to_native(E)` is expression-equivalent to:

- If `T` is a specialization of `empty_view` ([range.empty.view]), then
  `empty_view<T>{}`.
- Otherwise, `ranges::transform_view(std::views::all(E), @*big-endian-to-native-functor*@{})`.

## Feature test macro

Add the following macro definition to [version.syn]{.sref}, header `<version>`
synopsis, with the value selected by the editor to reflect the date of
adoption of this paper:

```cpp
#define __cpp_lib_endian_views 20XXXXL // also in <ranges>
```


