module;

#include <concepts>
#include <iterator>

export module p2728:traits;

namespace p2728 {

  using namespace std;

  template<class I>
  constexpr auto @*bidirectional-at-most*@() {    // @*exposition only*@
    if constexpr (bidirectional_iterator<I>) {
      return bidirectional_iterator_tag{};
    } else if constexpr (forward_iterator<I>) {
      return forward_iterator_tag{};
    } else if constexpr (input_iterator<I>) {
      return input_iterator_tag{};
    }
  }

  template<class I>
  using @*bidirectional-at-most-t*@ = decltype(@*bidirectional-at-most*@<I>()); // @*exposition only*@

  template<typename I, bool SupportReverse = bidirectional_iterator<I>>
  struct @*first-and-curr*@ {                         // @*exposition only*@
    @*first-and-curr*@() = default;
    @*first-and-curr*@(I curr) : curr{curr} {}
    template<class I2>
      requires convertible_to<I2, I>
        @*first-and-curr*@(const @*first-and-curr*@<I2>& other) : curr{other.curr} {}

    I curr;
  };
  template<typename I>
  struct @*first-and-curr*@<I, true> {                // @*exposition only*@
    @*first-and-curr*@() = default;
    @*first-and-curr*@(I first, I curr) : first{first}, curr{curr} {}
    template<class I2>
      requires convertible_to<I2, I>
        @*first-and-curr*@(const @*first-and-curr*@<I2>& other) : first{other.first}, curr{other.curr} {}

    I first;
    I curr;
  };

} // namespace p2728
