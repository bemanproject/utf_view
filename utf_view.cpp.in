module;

#include <concepts>
#include <cstdint>
#include <iterator>

export module p2728:utf_view;
import :concepts;

namespace p2728 {

  using namespace std;

  template<typename I>
  struct @*first-and-curr*@ {                         // @*exposition only*@
    @*first-and-curr*@() = default;
    @*first-and-curr*@(I curr) : curr{curr} {}
    template<class I2>
      requires convertible_to<I2, I>
      @*first-and-curr*@(const @*first-and-curr*@<I2>& other)
      : curr{other.curr} {}

    I curr;
  };
  template<bidirectional_iterator I>
  struct @*first-and-curr*@<I> {                // @*exposition only*@
    @*first-and-curr*@() = default;
    @*first-and-curr*@(I first, I curr) : first{first}, curr{curr} {}
    template<class I2>
      requires convertible_to<I2, I>
      @*first-and-curr*@(const @*first-and-curr*@<I2>& other)
      : first{other.first}, curr{other.curr} {}

    I first;
    I curr;
  };

  export template<@*code_unit*@ ToType, @*utf_range*@ V>
    requires ranges::view<V>
  class utf_view : public ranges::view_interface<utf_view<ToType, V>> {
  private:
    using @*iter*@ = ranges::iterator_t<V>;
    using @*sent*@ = ranges::sentinel_t<V>;

  public:
    class utf_iterator {

    public:
      using value_type = ToType;

      constexpr utf_iterator() = default;

      constexpr utf_iterator(@*iter*@ first, @*iter*@ it, @*sent*@ last)
        requires bidirectional_iterator<@*iter*@>
        : first_and_curr_{first, it}, last_(last) {
        if (curr() != last_)
          read();
      }
      constexpr utf_iterator(@*iter*@ /* first */, @*iter*@ it, @*sent*@ last)
        requires (!bidirectional_iterator<@*iter*@>)
        : first_and_curr_{move(it)}, last_(move(last)) {
        if (curr() != last_)
          read();
      }
      constexpr utf_iterator(@*iter*@ it, @*sent*@ last)
        requires (!bidirectional_iterator<@*iter*@>)
        : first_and_curr_{move(it)}, last_(move(last)) {
        if (curr() != last_)
          read();
      }

      template<class V2>
        requires convertible_to<ranges::iterator_t<V2>, @*iter*@> &&
                 convertible_to<ranges::sentinel_t<V2>, @*sent*@> &&
                 std::copyable<ranges::iterator_t<V2>>
          constexpr utf_iterator(const utf_view<ToType, V2>::utf_iterator& other) :
        buf_(other.buf_),
        first_and_curr_(other.first_and_curr_),
        buf_index_(other.buf_index_),
        buf_last_(other.buf_last_),
        last_(other.last_)
      {}

      constexpr @*iter*@ begin() const requires bidirectional_iterator<@*iter*@> { return first(); }
      constexpr @*sent*@ end() const { return last_; }

      constexpr @*iter*@ base() const requires forward_iterator<@*iter*@> { return curr(); }

      constexpr value_type operator*() const { return buf_[buf_index_]; }

      constexpr utf_iterator& operator++() {
        if (buf_index_ + 1 == buf_last_ && curr() != last_) {
          if constexpr (forward_iterator<@*iter*@>) {
            advance(curr(), to_increment_);
          }
          if (curr() == last_)
            buf_index_ = 0;
          else
            read();
        } else if (buf_index_ + 1 < buf_last_) {
          ++buf_index_;
        }
        return *this;
      }

      constexpr utf_iterator& operator--() requires bidirectional_iterator<@*iter*@> {
        if (!buf_index_ && curr() != first())
          read_reverse();
        else if (buf_index_)
          --buf_index_;
        return *this;
      }

      friend constexpr bool operator==(utf_iterator lhs, utf_iterator rhs)
        requires forward_iterator<@*iter*@> || requires (@*iter*@ i) { i != i; } {
        if constexpr (forward_iterator<@*iter*@>) {
          return lhs.curr() == rhs.curr() && lhs.buf_index_ == rhs.buf_index_;
        } else {
          if (lhs.curr() != rhs.curr())
            return false;

          if (lhs.buf_index_ == rhs.buf_index_ &&
            lhs.buf_last_ == rhs.buf_last_) {
            return true;
          }

          return lhs.buf_index_ == lhs.buf_last_ &&
               rhs.buf_index_ == rhs.buf_last_;
        }
      }

      friend constexpr bool operator==(utf_iterator lhs, @*sent*@ rhs) {
        if constexpr (forward_iterator<@*iter*@>) {
          return lhs.curr() == rhs;
        } else {
          return lhs.curr() == rhs && lhs.buf_index_ == lhs.buf_last_;
        }
      }

    private:
      constexpr void read();                                            // @*exposition only*@
      constexpr void read_reverse();                                    // @*exposition only*@

      constexpr @*iter*@ first() const requires bidirectional_iterator<@*iter*@>      // @*exposition only*@
        { return first_and_curr_.first; }
      constexpr @*iter*@& curr() { return first_and_curr_.curr; }              // @*exposition only*@
      constexpr @*iter*@ curr() const
        requires std::copyable<@*iter*@> { return first_and_curr_.curr; }         // @*exposition only*@
      constexpr @*iter*@ const& curr() const
        requires (not std::copyable<@*iter*@>) { return first_and_curr_.curr; }         // @*exposition only*@

      array<value_type, 4 / sizeof(ToType)> buf_;           // @*exposition only*@

      @*first-and-curr*@<@*iter*@> first_and_curr_;                                // @*exposition only*@

      uint8_t buf_index_ = 0;                                           // @*exposition only*@
      uint8_t buf_last_ = 0;                                            // @*exposition only*@
      uint8_t to_increment_ = 0;                                        // @*exposition only*@

      [[no_unique_address]] @*sent*@ last_;                                    // @*exposition only*@
    };

  private:
    V @*base_*@ = V();                                          // @*exposition only*@

    static constexpr auto make_begin(@*iter*@ first, @*sent*@ last) {   // @*exposition only*@
      return utf_iterator{first, first, last};
    }
    static constexpr auto make_end(@*iter*@ first, @*sent*@ last) {     // @*exposition only*@
      if constexpr (!same_as<@*iter*@, @*sent*@>) {
        return last;
      } else {
        return utf_iterator{first, last, last};
      }
    }

  public:
    constexpr utf_view() requires default_initializable<V> = default;
    constexpr utf_view(V base) : @*base_*@{move(base)} {}

    constexpr V base() const & requires copy_constructible<V> { return @*base_*@; }
    constexpr V base() && { return move(@*base_*@); }

    constexpr auto begin() {
      return make_begin(ranges::begin(@*base_*@), ranges::end(@*base_*@));
    }
    constexpr auto begin() const {
      return make_begin(ranges::begin(@*base_*@), ranges::end(@*base_*@));
    }

    constexpr auto end() {
      return make_end(ranges::begin(@*base_*@), ranges::end(@*base_*@));
    }
    constexpr auto end() const {
      return make_end(ranges::begin(@*base_*@), ranges::end(@*base_*@));
    }

    constexpr bool empty() const { return ranges::empty(@*base_*@); }

    friend ostream & operator<<(ostream & os, utf_view v);
    friend wostream & operator<<(wostream & os, utf_view v);

    // todo friendship with other utf_view/iterator
  };

} // namespace p2728
